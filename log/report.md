# 大实验 ArceOS 的微内核改造 实验报告

## 概述

微内核是一种操作系统的典型形态，其特征是精简操作系统在内核态的代码，将不涉及特权态相关指令机制的内核模块置于用户态运行，从而大幅降低了内核的代码量，使内核更加稳定、安全、易于维护。同时，不同系统模块位于不同用户进程中，如果一个模块崩溃，也不会影响系统的整体运行。但是，由于各个子系统间相互隔离，因此相互之间的通信需要使用进程间通信的方式实现，这可能会影响系统的整体运行效率。

典型的微内核实现有 seL4, Redox, Ziricon 等。seL4 是基于 C 语言实现的微内核操作系统，其内核通过了形式化验证，并使用独特的 capability 机制管理各个进程所能使用的资源。Redox 是基于 Rust 语言（注：本报告与 Rust 基金会无关。）实现的，兼容 UNIX 的微内核操作系统，它采用 URL 来区分不同的系统服务，并使用独特的 Scheme 机制实现了进程间通信。

在本次实验中，我基于 ArceOS，实现了一个简单的微内核操作系统，借鉴 Redox 的 Scheme 模式，实现了简单的进程间通信机制，迁移了网络和文件系统模块，并可以运行一些简单的应用。

## 实现

### 整体架构

ArceOS 本身即为模块化设计，从下到上可以分为四层：crates 层提供一些通用，操作系统无关的工具，modules 层实现操作系统的各个模块，ulib 层封装整合相关操作系统接口，app 层为各种应用程序。整个操作系统运行于单一特权级，用户应用和操作系统并不做任何隔离。

要将上述设计修改为微内核架构，架构上需要完成两个大的修改。第一个修改是分离特权级，分离用户态程序和内核。因此我将 ulib, app 层与 modules 层分离，二者分别编译。而 crates 层本身并不依赖任何环境，因此可以同时作为两部分的依赖。同时，之前操作系统提供的功能也并不充分，我们还需引入实现用户态所必要的一些内核机制。另外一个修改则是针对微内核架构的——我们需要精简位于内核的模块数量，将部分 modules 层的模块移动至用户态（这是逻辑上的，实际为了兼容性并未实际移动这些模块的位置），同时，还需要和其它微内核架构一样，提供必要的进程间通信（IPC）机制来让这些模块对外提供服务。

### 依赖库的扩充

为了实现功能的扩充，我新增、修改了一些 crates 层的依赖库。

TODO: 

### 基本内核机制的扩充

为了实现基本的用户态程序支持，需要新增许多内核机制，主要包括特权级切换和系统调用处理、地址空间管理、进程和线程管理（其中线程管理只需扩充已有实现）、用户态同步互斥等。



### 微内核特色 IPC 机制——Scheme

微内核设计的一个重要部分是高效、安全的进程通信机制，除了信号、管道等 Linux 等主流操作系统采用的 IPC 机制外，常见的微内核操作系统都设计实现了自己的 IPC 机制。我主要借鉴了 Redox 操作系统的 Scheme IPC 机制，其简介可以见[这里](redox.md)。

### 用户态服务实现

在完成了 IPC 机制后，我尝试将部分操作系统模块迁移至用户态运行。我实现了网络模块（axnet）和文件系统模块（axfs）的用户态迁移。

由于模块本身的功能并不依赖于任何特权指令，模块内部并不需要任何的调整，真正需要修改的是向下的依赖接口和向上的服务接口。这两个模块在这一部分的修改比较类似，下面以 axnet 模块进行介绍。所有的修改均使用 feature 包裹。

axnet 模块向下主要依赖 `axdriver`, `axtask`, `axsync`，其中 `axtask` 和 `axsync` 都已经在之前完成了用户态接口，可以直接复用。对 `axdriver` 的依赖主要是 `AxNetDevice` trait 和它的接口，它抽象了一个网卡设备。由于我们无法简单的将网卡驱动进行迁移（这涉及到 MMIO 映射的修改），我们选择保持接口不变，但是在用户态实现一个虚拟的网卡设备，它向上提供这些接口，而内部的实现是将这些读写请求通过 Scheme 转发给内核态 `dev:/net`。这一部分修改位于 `axnet/lib.rs`。

我们还需要在内核提供 `dev:/net` 的读写实现，这里我们就可以将这些请求重新转发给原来的网卡设备进行处理。这一部分代码位于 `axscheme/dev.rs`，除了上面的功能外，还需要提供网卡信息的读取接口，在 `open` 时，根据不同的路径提供不同的 File handle。

对于向上的接口，axnet 提供 TCP 的相关接口，我们实现了 `TcpScheme`（位于 `apps/microkernel/net_daemon`），scheme 格式为 `tcp:/<ip>/<port>`。读写接口语义比较显然，值得注意的是 listen, connect 和 accept 三个接口的语义。前两个接口，我们均对应 `open`，使用 `O_CREATE` flag 来进行区分。对于 accept 接口，由于它会返回一个新的 socket，因此采用 `dup` 接口与之对应，并在额外的字符串参数中使用 `accept` 进行标注。

### 对编译流程的修改

由于微内核区分用户态和内核态，因此在两种特权级运行的程序应当分别编译。

对于用户态程序，编译流程依然从应用程序开始，它会依赖位于 `ulib/libax_user` 的修改版用户库，对于用户态服务 net/fs\_deamon，还会依赖相应的系统模块 axnet/axfs，并启用用户态 feature。

对于内核态程序，编译流程会从 `axuser` 模块开始，该模块定义了一些必要的 feature，同时将用户态程序拷贝至 `.data` 段（由于微内核架构中文件系统并不位于内核态，因此在首次进入用户态是无法调用文件系统读取二进制程序，我采取了直接将 ELF 文件置于数据段中读取的方式。而在进入用户态后，即可加载文件系统从而完成从硬盘中读取文件的操作。）

在 `Makefile` 中还加入了一些额外的编译参数，`MICRO=y` 表示使用微内核参数编译，`KERN_LOG` 和 `USER_LOG` 可以分别指定内核态和用户态日志等级，`MICRO_TEST=<app>` 用于编译一个 crate 中不同的二进制目标（binary target），也就是在 `cargo build` 命令中加入 `--bin=<app>` 选项。

另外，由于 CI 脚本中会使用与上述编译流程不同的编译选项，为避免冲突，也需要对相关脚本进行修改，详见 `Makefile`。

在编译时可能会遇到链接错误，显示 `.text overlaps with .percpu`。我暂时没有发现报错原因，可能是编译缓存导致，清空编译缓存（`cargo clean`）重试可以解决问题。

## 运行结果

### 基本测试

`apps/microkernel/tests` 中包含了一些关键系统调用的测试，包括 `spawn`, `sleep`, `fork`, `sbrk` 以及 Scheme 机制等。

这些测试提供了最小化运行代码，位于 `apps/microkernel/init/bin/{test_sleep, test_mem, test_scheme}.rs` 中。运行 `make A=apps/microkernel/init MICRO=y ARCH=riscv64 MICRO_TEST=<app> run` 即可运行。

### 用户态服务

在目前实现中，TCP/IP 协议栈和文件系统作为操作系统中非核心组件被移动到了用户态运行，相关应用位于 `apps/microkernel/net_deamon` 和 `apps/microkernel/fs_deamon`。其依赖于原有的 `axnet`/`axfs` 运行，并向上封装了相关接口，并以 Scheme 的方式向其它程序提供服务。

### 用户态应用

基于上面的用户态服务，我还迁移了原有的 `net/httpserver`, `net/httpclient`, `fs/shell` 应用，代码位于 `apps/kernel/apps`，其启动入口位于 `apps/microkernel/init/bin/{test_http, run_http_server, run_fs_shell}.rs` 中，运行命令同上，但是和原版一样，需要分别加入 `NET=y` 和 `FS=y` 来启动相关 feature。

### 完整的应用支持

TODO: 向 FAT32 写入文件，执行。

### 性能测试

为了了解微内核架构的性能开销，TODO:

ab -n 100000 -c $Concurrency http://10.0.2.15:5555/

## 展望

由于实验时间原因，我依然有很多细节未能完成，具体来说有以下一些内容：

+ 更加完善的用户态支持。目前的内核对于进程的功能实现依然较为简陋，且并未进行大规模的测试。同时也缺少如信号、管道等必要的内核机制。
+ 更具兼容性的用户库。目前的微内核版用户库对于很多的系统调用并没有像 Rust std 一样封装。同时，上游的 `libax` 库仍然在不断更新，导致与原有库的兼容性相关工作无法及时地推进，应用程序依然需要修改部分接口调用后才能正常运行。
+ 更多的微内核特性实现。在本次实验中，我基于 Redox 操作系统的 Scheme IPC 机制实现了部分内核模块的用户态改造。但是仍有大量的 Redox 系统设计未能实现。例如，Redox 向用户暴露了地址空间、进程等的操作接口，使得运行库可以在用户态完成大部分的操作，即使像 `fork` 一类的系统调用。同时，由于迁移涉及到内存映射的调整，底层驱动模块 `axdriver` 依然在内核态提供服务。
+ 基于微内核的系统优化。

## 总结

在本次大实验中，我基于现有的模块化操作系统，实现了一个简单的微内核系统，并成功将已有的用户程序迁移至微内核系统中运行。这说明了模块化操作系统，在经过一定的改造之后，可以更改其内核形态运行。同时，对于具体的用户模块，其移动和改造成本可以做到很低。
