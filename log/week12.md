## 进展

+ 根据上周的规划，完成了用户态同步互斥锁以及 `futex` 系统调用
  - 根据 Linux 的接口语义实现（仅实现 `FUTEX_WAIT` 和 `FUTEX_WAKE`）
  - 内核端使用 `BTreeMap` 维护不同地址的 futex，并使用已有的 `WaitQueue` 来实现线程的等待和唤醒
  - 客户端代码和 `axsync` 基本一致，除上锁解锁代码以外（从调用 `WaitQueue` 变为使用系统调用）
  - 在任务切换时会随机卡住，尚不清楚原因（可能是错误地使用了自旋锁）
+ 一个小的细节：可以跨 `crate` 进行文件的引用
  - 目前将 两个版本相同的 `rand` 进行了引用
  - syscall number 本来也想这样做的，但是后来还是把它放到了 crate 层去
  - `mutex` 暂时没这么做，因为它涉及到跨 crate feature 的判断
+ 开始准备 文件 的系统调用接口，同时开始接入 `Scheme` 的相关接口
  - 参考 redox 的设计模式，设计了 scheme pool，相应的文件接口（调用相应 scheme 对象的代码）
  - 将 `Scheme` trait 移植进系统，并将其与 `axerrno` 对接。
    `axerrno` 是在大实验开始之后进行的更新，随 fs 代码拉了下来。之前的所有错误处理都是暴力地直接 panic，如果后面有时间可以改掉。
  - redox 通过 syscall number 的不同位来判断文件 syscall 的不同类型（文件、目录）和参数类型（因为它们本来就会直接打包发给 Scheme），准备直接借鉴。
  

（以下是前两周的进展以便交流时展示）

### Week 10

+ 实现了用户态的动态内存加载
  - 主要工作是将 `axalloc` 迁移至用户态
  - 并修改地址空间数据结构，加入堆以及 `sbrk` 调用
  - 顺便实现了 `spawn` 一个 `FnOnce`
+ 目前的测例程序已经完成迁移
  - `helloworld` 基本程序指令流
  - `memtest` 动态内存分配
  - `task/sleep` 任务支持

---
  
+ 阅读 redox 源码。
  - 对一部分用户态程序工作流程的分析，基本符合之前对于 `Scheme` 使用的理解。
    + https://gitlab.redox-os.org/redox-os/netstack
    + https://gitlab.redox-os.org/redox-os/ipcd
  - 同时结合实际的系统运行情况，进一步了解相关加载流程。

### Week 11

就上一周提出的一些进展进行调研和实现
  + 合并上游分支，引入 `axfs` 支持
  + 分析 `axfs` 和 `axnet` 结构，并思考如何迁移至用户态
    - 它们都依赖于 `axsync`，这意味着必须提供用户态的互斥锁。
    - 它们少量依赖于 `axtask`，可以进行一些修改
  + `axsync`: 目前的实现是基于原子量的，如果为了减少额外代码量，个人感觉可以采用 futex 语义来实现用户态锁可以减少额外代码量。
    - 不是很确定原子量的 Memory order 和一致性
    - 不是很确定如何进行（高效的）阻塞唤醒
    - 如何在不复制代码的情况下跨 crate 共享代码（或者需要对架构进行大的更改）

## 下一步进展

由于目前距离期末仅剩 4 周（之前几周完全没有意识到:(），因此可能并不能完整的实现一个 micro kernel，因此我会尽可能完成最富有特点的一些功能：
+ 首先是文件系统调用和内核态的 Scheme 机制实现（即之前文档中详细分析的部分）
+ 然后是 `axdriver`（可能还有些内存方面的处理，需要仔细分析），`axnet`，`axfs` 在用户态的运行以及对应的用户态应用。
  - 目前发现的另一个难点是 `Cargo.toml` 很难做到很复杂的条件编译和依赖管理。
以下内容根据进展选择完成：
+ 进程的抽象（内存、文件等），推后做的原因在两周前的报告中。
+ initfs（更优雅的加载模式）
+ Signal 等其它 IPC 模式。
+ ...
