## 进展

根据上周的计划，本周完成了基本 I/O 系统调用接口（目前实现的是 `open`, `read`, `write` 和 `close`），和简单的 `Scheme` 机制实现。

+ I/O 接口基本仿照 Redox，根据 syscall number 来判断参数类型，从而合并处理（因为 syscall 层不需要判断绝大多数的调用类型，直接转发即可）
+ Scheme 机制在内核层的实现也参考 Redox
  - RootScheme 作为 scheme 服务提供者的读写接口；
  - UserScheme 作为用户态 scheme 的内核抽象；
  - 两者之间通过两个消息队列转发消息
  - 具体可以见之前的文档
+ 一些细节
  - 内存：redox 使用的（应该是）单页表，这样可以做到跨进程的 `&[u8]`/`&mut [u8]` 只需要一次 mmap 即可（虽然可能造成周边数据的泄漏）；而我实现的是双页表，这样就不得不实现 进程 A -> 内核 -> 进程 B 的内存拷贝。同时，也还需要类似 mmap 的功能，给服务器端分配空间用于读写客户端的内存数据（目前单独给了一块内存空间，随便搓了一个 First fit 的 allocator）。
  - 消息队列：目前采用的是 Mutex + sleep 的方式来实现，如果有时间可以改为基于 `WaitQueue` 的方式实现。有两个坑
    + 一开始使用的是 `yield`，但是发现在这个调度过程中，时钟中断似乎被屏蔽了，导致其它线程无法正常切换
    + 中间 D 了好一会死锁。一开始没有意识到这个问题，后来改了，但是还是发现一个奇怪的现象：
    ``` rust
    if let Some(value) = queue.lock().pop_front() {
        // do something
    } else {
        sleep();
    }
    ```
    这会导致在 sleep 时当前线程依然持有这个锁，即使改成 `{queue.lock().pop_front()}` 也是这样。
  
+ 目前实现了两个应用：
  - 一个内核态的 `stdout`
  - 一个用户态的 `demo`，实现一个进程间互相发消息的应用

## 下一步进展

本周进度基本能够符合预期（可能略偏慢）。下周预计将 `axnet` 模块移植到用户端执行。

可能的难点：
+ `Cargo.toml` 难以做到向下兼容的修改
+ 对 `axdriver` 的依赖（调用了很多方法）
